<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Космический Бегун 3D</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .ui-layer { pointer-events: none; }
        .interactive { pointer-events: auto; }
    </style>
</head>
<body class="text-white select-none">

    <!-- 3D Container -->
    <div id="game-container"></div>

    <!-- UI Layer -->
    <div class="absolute inset-0 flex flex-col justify-between p-6 ui-layer z-10">
        <!-- Header / Score -->
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-2xl font-bold text-cyan-400 drop-shadow-md">Космический Бегун</h1>
                <p class="text-sm text-gray-400">Избегайте красных блоков</p>
            </div>
            <div class="text-right">
                <div class="text-4xl font-mono font-bold text-yellow-400" id="score">0</div>
                <div class="text-xs text-gray-500">СЧЕТ</div>
            </div>
        </div>

        <!-- Controls Hint -->
        <div class="text-center text-gray-500 text-sm mb-4 hidden sm:block" id="controls-hint">
            Используйте <span class="font-bold text-white">←</span> и <span class="font-bold text-white">→</span> для движения
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 flex items-center justify-center bg-black/80 z-20 transition-opacity duration-500 interactive backdrop-blur-sm">
        <div class="text-center max-w-md p-8 border border-cyan-500/30 rounded-2xl bg-gray-900/90 shadow-[0_0_30px_rgba(6,182,212,0.3)]">
            <h2 class="text-5xl font-black mb-2 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600">3D RUNNER</h2>
            <p class="text-gray-300 mb-4 text-lg">Выберите сложность:</p>
            
            <div class="flex gap-2 justify-center mb-8" id="difficulty-selector">
                <button class="diff-btn px-3 py-2 rounded-lg border border-green-500/50 text-green-400 hover:bg-green-500/20 transition-all cursor-pointer" data-diff="easy">Легко</button>
                <button class="diff-btn px-3 py-2 rounded-lg border border-yellow-500/50 text-yellow-400 bg-yellow-500/20 hover:bg-yellow-500/30 transition-all ring-2 ring-yellow-500/50 font-bold scale-105 cursor-pointer" data-diff="normal">Нормально</button>
                <button class="diff-btn px-3 py-2 rounded-lg border border-red-500/50 text-red-400 hover:bg-red-500/20 transition-all cursor-pointer" data-diff="hard">Сложно</button>
            </div>

            <button id="start-btn" class="w-full px-8 py-4 bg-gradient-to-r from-cyan-500 to-blue-600 rounded-full text-xl font-bold text-white hover:scale-105 transition-transform shadow-lg cursor-pointer">
                НАЧАТЬ ИГРУ
            </button>
            <div class="mt-6 text-sm text-gray-500">
                <p>Управление: Стрелки, A/D или Ф/В</p>
            </div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden absolute inset-0 flex items-center justify-center bg-red-900/80 z-30 interactive backdrop-blur-md">
        <div class="text-center max-w-md p-8 border border-red-500/50 rounded-2xl bg-gray-900/95 shadow-[0_0_50px_rgba(239,68,68,0.5)]">
            <h2 class="text-5xl font-black mb-2 text-red-500">CRASH!</h2>
            <p class="text-gray-300 mb-2">Вы разбились</p>
            <div class="text-6xl font-mono font-bold text-yellow-400 mb-8" id="final-score">0</div>
            <button id="restart-btn" class="px-8 py-4 bg-gradient-to-r from-red-500 to-orange-600 rounded-full text-xl font-bold text-white hover:scale-105 transition-transform shadow-lg cursor-pointer">
                ИГРАТЬ СНОВА
            </button>
            <button id="menu-btn" class="mt-4 block w-full px-8 py-3 border border-red-500/30 rounded-full text-lg font-bold text-red-200 hover:bg-red-900/50 transition-colors cursor-pointer">
                В МЕНЮ
            </button>
        </div>
    </div>

    <script>
        // Game Configuration
        let config = {
            laneWidth: 2.5, 
            speed: 0.28,     // Default (Normal)
            maxSpeed: 0.50, 
            speedIncrement: 0.00002, 
            obstacleSpawnRate: 25, 
        };
        
        const difficultySettings = {
            easy: { speed: 0.20, maxSpeed: 0.35, spawnRate: 30, speedInc: 0.00001 },
            normal: { speed: 0.28, maxSpeed: 0.50, spawnRate: 25, speedInc: 0.00002 },
            hard: { speed: 0.40, maxSpeed: 0.70, spawnRate: 20, speedInc: 0.00004 } 
        };

        // State
        let state = {
            isPlaying: false,
            score: 0,
            lane: 0, // -1 (left), 0 (center), 1 (right)
            speed: config.speed,
            frame: 0
        };

        // Three.js Variables
        let scene, camera, renderer;
        let player, floor, gridHelper, stars;
        let obstacles = [];
        let particles = [];
        
        // DOM Elements
        const scoreEl = document.getElementById('score');
        const finalScoreEl = document.getElementById('final-score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');

        // Initialization
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.Fog(0x050510, 10, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 3, 8);
            camera.lookAt(0, 0, -5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);
            
            // Add some colored lights for atmosphere
            const blueLight = new THREE.PointLight(0x00ffff, 0.5, 20);
            blueLight.position.set(-5, 2, -5);
            scene.add(blueLight);
            
            const pinkLight = new THREE.PointLight(0xff00ff, 0.5, 20);
            pinkLight.position.set(5, 2, -15);
            scene.add(pinkLight);

            // Player (The Ship/Cube)
            const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
            // Create a cool material for the player
            const playerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                roughness: 0.1,
                metalness: 0.8,
                emissive: 0x004444,
                emissiveIntensity: 0.5
            });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.castShadow = true;
            player.position.y = 0.5;
            scene.add(player);
            
            // Add a trail/engine glow to player
            const engineGeo = new THREE.BoxGeometry(0.6, 0.6, 0.2);
            const engineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const engine = new THREE.Mesh(engineGeo, engineMat);
            engine.position.z = 0.5;
            player.add(engine);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(100, 200);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x11111a, 
                roughness: 0.8,
                metalness: 0.2
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.z = -50;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grid (Retro Vaporwave Style)
            gridHelper = new THREE.GridHelper(200, 80, 0xff00ff, 0x222222);
            gridHelper.position.z = -50;
            scene.add(gridHelper);

            // Stars
            const starGeo = new THREE.BufferGeometry();
            const starCount = 1000;
            const starPos = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) {
                starPos[i] = (Math.random() - 0.5) * 200;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true});
            stars = new THREE.Points(starGeo, starMat);
            scene.add(stars);

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleInput);
            
            // Touch support
            let touchStartX = 0;
            document.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
            });
            document.addEventListener('touchend', e => {
                const touchEndX = e.changedTouches[0].screenX;
                if (touchEndX < touchStartX - 30) moveLeft();
                if (touchEndX > touchStartX + 30) moveRight();
            });

            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', resetGame);
            document.getElementById('menu-btn').addEventListener('click', goToMenu);

            // Difficulty Selection Logic
            const diffBtns = document.querySelectorAll('.diff-btn');
            
            function getBtnColor(btn) {
                if (btn.dataset.diff === 'easy') return 'green';
                if (btn.dataset.diff === 'normal') return 'yellow';
                if (btn.dataset.diff === 'hard') return 'red';
                return 'gray';
            }

            diffBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Reset all buttons to base style
                    diffBtns.forEach(b => {
                        const c = getBtnColor(b);
                        b.className = `diff-btn px-3 py-2 rounded-lg border border-${c}-500/50 text-${c}-400 hover:bg-${c}-500/20 transition-all cursor-pointer`;
                    });
                    
                    // Set active style for clicked button
                    const target = e.currentTarget;
                    const color = getBtnColor(target);
                    target.className = `diff-btn px-3 py-2 rounded-lg border border-${color}-500/50 text-${color}-400 bg-${color}-500/20 hover:bg-${color}-500/30 transition-all ring-2 ring-${color}-500/50 font-bold scale-105 cursor-pointer`;
                    
                    // Apply settings
                    const diff = target.dataset.diff;
                    const settings = difficultySettings[diff];
                    if (settings) {
                        config.speed = settings.speed;
                        config.maxSpeed = settings.maxSpeed;
                        config.obstacleSpawnRate = settings.spawnRate;
                        config.speedIncrement = settings.speedInc;
                    }
                });
            });

            // Start Loop
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function handleInput(event) {
            if (!state.isPlaying) return;

            // Supports Arrows, WASD, and Russian layout (Ф/В)
            if (['ArrowLeft', 'a', 'A', 'ф', 'Ф'].includes(event.key)) {
                moveLeft();
            } else if (['ArrowRight', 'd', 'D', 'в', 'В'].includes(event.key)) {
                moveRight();
            }
        }

        function moveLeft() {
            if (state.lane > -1) state.lane--;
        }

        function moveRight() {
            if (state.lane < 1) state.lane++;
        }

        function startGame() {
            startScreen.classList.add('opacity-0', 'pointer-events-none');
            resetGameState();
            state.isPlaying = true;
        }

        function resetGame() {
            gameOverScreen.classList.add('hidden');
            resetGameState();
            state.isPlaying = true;
        }

        function goToMenu() {
            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('opacity-0', 'pointer-events-none');
            resetGameState();
            state.isPlaying = false;
        }
        
        function resetGameState() {
            state.score = 0;
            state.lane = 0;
            state.speed = config.speed;
            state.frame = 0;
            scoreEl.innerText = "0";
            
            // Remove all obstacles
            obstacles.forEach(obs => scene.remove(obs.mesh));
            obstacles = [];
            
            // Reset player position
            player.position.x = 0;
            player.rotation.z = 0;
            player.rotation.y = 0; // Fix potential rotation from idle animation
            player.rotation.x = 0;
        }

        function createObstacle() {
            // Random lane: -1, 0, or 1
            const lane = Math.floor(Math.random() * 3) - 1;
            
            const geometry = new THREE.BoxGeometry(2, 2, 2); // Slightly smaller than lane width
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xff0044,
                roughness: 0.4,
                metalness: 0.5,
                emissive: 0x550000
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(lane * config.laneWidth, 1, -50); // Spawn far away
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            scene.add(mesh);
            obstacles.push({ mesh, lane, active: true });
        }
        
        function createExplosion(position) {
            const particleCount = 20;
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.position.x += (Math.random() - 0.5);
                particle.position.y += (Math.random() - 0.5);
                particle.position.z += (Math.random() - 0.5);
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5 + 0.2
                );
                
                scene.add(particle);
                particles.push({ mesh: particle, velocity, life: 1.0 });
            }
        }

        function gameOver() {
            state.isPlaying = false;
            finalScoreEl.innerText = Math.floor(state.score);
            gameOverScreen.classList.remove('hidden');
            createExplosion(player.position);
        }

        function update() {
            if (!state.isPlaying) {
                // Idle animation for start screen
                if (player) {
                    player.rotation.z = Math.sin(Date.now() * 0.002) * 0.1;
                    player.rotation.y = Math.sin(Date.now() * 0.001) * 0.1;
                }
                return;
            }

            state.frame++;
            
            // Increase score
            state.score += state.speed;
            scoreEl.innerText = Math.floor(state.score);

            // Increase difficulty
            if (state.speed < config.maxSpeed) {
                state.speed += config.speedIncrement;
            }

            // Smooth player movement
            const targetX = state.lane * config.laneWidth;
            // Slower lateral lerp for smoother feel
            player.position.x += (targetX - player.position.x) * 0.1;
            
            // Tilt player based on movement - Subtle and self-correcting
            const tiltStrength = 0.15;
            const diff = player.position.x - targetX;
            const targetRotation = diff * tiltStrength;
            
            // Smoothly interpolate rotation
            player.rotation.z += (targetRotation - player.rotation.z) * 0.1;
            
            // Force snap to 0 if very close to prevent permanent tilt
            if (Math.abs(diff) < 0.01) player.rotation.z = 0;
            
            // Bobbing effect
            player.position.y = 0.5 + Math.sin(state.frame * 0.1) * 0.05;

            // Move grid to simulate speed
            gridHelper.position.z += state.speed;
            if (gridHelper.position.z > -50 + 2.5) {
                gridHelper.position.z = -50;
            }

            // Move stars
            if (stars) {
                stars.position.z += state.speed * 0.5;
                if (stars.position.z > 50) stars.position.z = 0;
            }

            // Spawn Obstacles
            // Spawn rate gets faster as speed increases
            const currentSpawnRate = Math.max(15, Math.floor(config.obstacleSpawnRate / state.speed * 0.5));
            if (state.frame % currentSpawnRate === 0) {
                createObstacle();
            }

            // Update Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.mesh.position.z += state.speed; // Move towards player

                // Collision Detection
                // Simple box collision
                if (obs.active) {
                    // Z-axis check (depth)
                    if (obs.mesh.position.z > -1.5 && obs.mesh.position.z < 1.5) {
                        // X-axis check (lane) - check if player is close enough to obstacle center
                        if (Math.abs(obs.mesh.position.x - player.position.x) < 1.5) {
                            gameOver();
                        }
                    }
                }

                // Remove if passed camera
                if (obs.mesh.position.z > 10) {
                    scene.remove(obs.mesh);
                    obstacles.splice(i, 1);
                }
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.life -= 0.02;
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                    continue;
                }
                
                p.mesh.position.add(p.velocity);
                p.mesh.rotation.x += 0.1;
                p.mesh.rotation.y += 0.1;
                p.mesh.scale.setScalar(p.life);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            updateParticles();
            renderer.render(scene, camera);
        }

        // Boot
        init();

    </script>
</body>
</html>